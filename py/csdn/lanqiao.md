@[TOC](蓝桥杯初中python试题)
# 编程题
作者：Jeefy，xsh\_Fu
邮箱：jeefy163@163.com / jeefyol@outlook.com
github: jeefies@github.com
> 源代码都在文章之中，仅供参考
## 自我评价
> 对于我这个初二的初中生来说还是很简单的  
> 3道比较常规的题和3道算法题（也不完全是）

总而言之，每一个的思路都比较清晰，运算方法是我所能想到最好的方法了。
题目都是从考试试题上抄下来的，没有改动。

## 题目 1
给定N个数字（包含整数和浮点数），找到N个数字中最大的数字。所给数字以英文逗号分割。
**分析** :
*利用内置max函数实现寻找最大值*  
*在最后判断是否应该以整数形式输出*。
```python
# 先把所有数字转为浮点型
m = max(map(float, input().split(',')))
# 用除以1的余数判断是否要转为整数输出
print(m if m % 1 else int(m))
```

## 题目 2
给定一个合数N，将N分解质因数后，输出其质因数个数。
**分析** :
*分解质因数可以参考短除法的实现方式，一个一个数从小到大一个一个除*  
> 补充：当一个数已经没有了比N小的质因数时，这个数便不会被任何一个小于N^2^的合数整除

```python
i = int(input())
def count(i):
	# _i 作为 i 的副本，因为之后 i 会被改变
	# n 为结果个数
	# m 为除数，质数从2开始（1既不是合数，也不是质数）
	_i, n, m = i, 0, 2
	# 其实更好的是 m < math.ceil(math.sqrt(_i)) + 1
	# 但是没有太大必要，除非很注重速度
	while m < _i:
		if i % m == 0: 
			# 能被一个质数整除
			i /= m
			n += 1
			# 再次看看能否被这个数整除
		else:
			# 不能被整除，下一个树
			m += 1
	return n
```

## 题目 3
给定一个含有字母和数字的字符串，输出此字符串中最长的==数字子串==的长度。
如：字符串“a2a22d”，最长的数字子串为22，长度为2，故输出2。字符串“lq12h567j765”，最长的数字子串为567和765，长度都为3，故输出3。
**分析** :
*其实可以用正则表达式来寻找所有数字子串*
*恰巧可以用内置re库实现*

```python
import re
# 寻找数字连续出现的子串
li = re.findall("\d+", input())
# 将每一个子串变成其长度，利用max寻找最大值
print(max(map(len, li)))
```

## 题目 4
给定一个大于2的偶数，在所有满足==可以由两个质数相加得到==这个特点的质数对中，找出两个质数差值==最小==的一对，并将差值输出。
（差值为大数减小数的值，两个质数相等时差值为0）
**分析**:
*两数相加相等，求差最小，所以从中间开始，向两边找满足是质数的两个数*

```python
import math

def check(i):
	# 判断是否是质数
    m = math.ceil(math.sqrt(i)) + 1
    #由于range是后闭环，所以必须要+1才能取到最大的到
    # 如果想要偷懒，把m换成i就行，与第2题类似
    for j in range(2, m):
        if i % j == 0:
            return False
    return True

def get(i):
	# 获得差为0或1的最中间的两个数
	# left 永远小于 right
    left = i // 2
    right = i - left
    # 循环直到 left = 2
    for _ in range(2, left+1):
        if check(left) and check(right):
            return right - left
        left -= 1
        right += 1

    return i - 1

print(get(int(input())))
```
## 题目 5
孙悟空的金箍棒可以变高也可以变矮还可以变出多个金箍棒。
这天孙悟空无聊变出了N个长短不一的金箍棒，这些金箍棒之间相互吵闹，攀比谁高。
当孙悟空每次手指其中一个金箍棒时，这个金箍棒高度不变，其他的金箍棒高度都会增加1。
只有当所有金箍棒高度都一样时，他们之间才不相互吵闹，也不会再增加高度，保持静止。

分别给定N个金箍棒的初始高度，请你帮助孙悟空计算一下至少手指几次可以让N个金箍棒高度都一样。

例如: 有3个金箍棒，初始高度分别为2，3，4。
第一次手指第三个金箍棒，第三个金箍棒高度不变，第一和第二个金箍棒高度分别增加1，变为3，4，4；
第二次手指第二个金箍棒，第二个金箍棒高度不变，第一和第三个金箍棒高度分别增加1，变为4，4，5；
第三次手指第三个金箍棒，第三个金箍棒高度不变，第一和第二个金箍棒高度分别增加1，变为5，5，5；
这时3个金箍棒的高度都为5，手指3次后金箍棒高度一样。所以至少手指3次才能使金箍棒高度都一样。

输入描述
输入N个非全部相等的正整数（N个数不全部相等，2\<N\<31）
且之间以英文逗号隔开，分别表示N个金箍棒的初始高度

输出描述
输出一个正整数，表示至少手指几次才能使金箍棒高度都一样

**分析**:
*实际上就是给你一组数字，每一次操作都可以让一个数之外的所有数字加一（==或者可以看成让一个数减一==）*
*多少次操作之后，可以让整个数组相同*
*所以我们的思路就是让所有数减少，到==最小数==的大小*

```python
li = list(map(int, input().split(',')))
m = min(li)
count = sum(li) - m * len(li)
print(count)
```
这是思路理的==非常==清楚后的代码。

或者我们可以按照相对常规一点的思路（还是像我说的一样，可以看作让一个数减少
```python
li = list(map(int, input().split(',')))
li.sort() # 从小到大排序

n = 0 # 最后的结果
def add(x):
    li[x + 1] -= 1
    
for i in range(len(li) - 1):
    x = li[i + 1] - li[i] 
    # 把每一个都变成上一个数所需要x次操作
    # 然后就实际操作
    for _ in range(x): add(i)
    n += x

print(n)
```

## 题目 6
首先在指定坐标的方格内放置红色的花卉（每个方格放一盆）
在（==100x100==）的坐标系之中
完成后，找出最多有多少盆红色花卉在同一条直线上。
（同一直线包含同一列、同一行、同一对角线，红色花卉可以连续也可以不连续）

输入描述
输入n对正整数，每一对正整数之间以一个空格隔开，
代表放置红色花卉的方格位置。每对正整数中的两个数字以英文逗号隔开

输出描述
输出最多有多少盆红色花卉在同一条直线上

**分析**:
*这个东西啊，我确实不知道应该如何快速实现，不过这个操作非常简单，所以我们只需要==硬算==就可以了*

```python
matrix = [[0 for _ in range(100)] for _ in range(100)]

def proc(stri):
	# 把输入的坐标变成1
    def put(strin):
        x, y = map(int, strin.split(','))
        # 注意下标与坐标之间相差1
        matrix[y - 1][x - 1] = 1
    for p in stri.split():
        put(p)

def result(matrix):
    m = 0
    # 首先是横向寻找最大
    for i in range(100):
        s = sum(matrix[i])
        if s > m:
            m = s
    # 再是竖着寻找（一列一列的）
    for i in range(100):
        s = sum(matrix[x][i] for x in range(100))
        if s > m:
            m = s
    # 接下来是斜着
    # 这两个循环是向左倾斜
    for i in range(100):
        s = sum(matrix[i + x][99 - x] for x in range(100 - i))
        if s > m:
            m = s
    for i in range(100):
        s = sum(matrix[x][i - x] for x in range(i))
        if s > m:
            m = s
    # 剩下两个是向右倾斜
    for i in range(100):
        s = sum (matrix[x][i + x] for x in range(100 - i))
        if s > m:
            m = s
    for i in range(100):
        s = sum (matrix[i + x][x] for x in range(100 - i))
        if s > m:
            m = s
    # 最后的结果就出来了
    return m

# 处理输入到坐标数组之中，数组初始所有为0
# 只有有东西的地方为1
proc(input())
# 最后的结果
print(result(matrix))
```

以上皆为我个人解题思路，不代表标准答案。仅供参考。

转载请注明出处
